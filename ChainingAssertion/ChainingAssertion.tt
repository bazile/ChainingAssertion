<#@ assembly Name="System.Core.dll" #>
<#@ import namespace="System.Linq" #>
/*--------------------------------------------------------------------------
 * Chaining Assertion for MSTest
 * ver 1.0.0.0 (Feb. 22th, 2011)
 *
 * created and maintained by neuecc <ils@neue.cc - @neuecc on Twitter>
 * licensed under Microsoft Public License(Ms-PL)
 * http://chainingassertion.codeplex.com/
 *--------------------------------------------------------------------------*/

/* -- Tutorial --
 * | at first, include this file on MSTest Project.
 * 
 * | three example, "Is" overloads.
 * 
 * // This same as Assert.AreEqual(25, Math.Pow(5, 2))
 * Math.Pow(5, 2).Is(25);
 * 
 * // This same as Assert.IsTrue("foobar".StartsWith("foo") && "foobar".EndWith("bar"))
 * "foobar".Is(s => s.StartsWith("foo") && s.EndsWith("bar"));
 * 
 * // This same as CollectionAssert.AreEqual(Enumerable.Range(1,5), new[]{1, 2, 3, 4, 5})
 * Enumerable.Range(1, 5).Is(1, 2, 3, 4, 5);
 * 
 * | and two extension methods.
 * 
 * Object obj = null;
 * obj.IsNull();    // Assert.IsNull(obj)
 * obj.IsNotNull(); // Assert.IsNotNull(obj)
 * 
 * | Parameterized Test
 * | TestCase takes parameters and send to TestContext's Extension Method "Run".
 * 
 * [TestClass]
 * public class UnitTest
 * {
 *     public TestContext TestContext { get; set; }
 * 
 *     [TestMethod]
 *     [TestCase(1, 2, 3)]
 *     [TestCase(10, 20, 30)]
 *     [TestCase(100, 200, 300)]
 *     public void TestMethod2()
 *     {
 *         TestContext.Run((int x, int y, int z) =>
 *         {
 *             (x + y).Is(z);
 *             (x + y + z).Is(i => i < 1000);
 *         });
 *     }
 * }
 * 
 * | TestCaseSource
 * | TestCaseSource can take static field/property that types is only object[][].
 * 
 * [TestMethod]
 * [TestCaseSource("toaruSource")]
 * public void TestTestCaseSource()
 * {
 *     TestContext.Run((int x, int y, string z) =>
 *     {
 *         string.Concat(x, y).Is(z);
 *     });
 * }
 * 
 * public static object[] toaruSource = new[]
 * {
 *     new object[] {1, 1, "11"},
 *     new object[] {5, 3, "53"},
 *     new object[] {9, 4, "94"}
 * };
 * 
 * -- more details see project home --*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Microsoft.VisualStudio.TestTools.UnitTesting
{
    #region Extensions

    public static class ChainingAssertion
    {
        /// <summary>Assert.IsNull</summary>
        public static void IsNull<T>(this T value)
        {
            Assert.IsNull(value);
        }

        /// <summary>Assert.IsNotNull</summary>
        public static void IsNotNull<T>(this T value)
        {
            Assert.IsNotNull(value);
        }

        /// <summary>Assert.AreEqual</summary>
        public static void Is<T>(this T actual, T expected, string message = "")
        {
            Assert.AreEqual(expected, actual, message);
        }

        /// <summary>Assert.IsTrue(predicate(obj))</summary>
        public static void Is<T>(this T obj, Expression<Func<T, bool>> predicate, string message = "")
        {
            var paramName = predicate.Parameters.First().Name;
            var msg = string.Format("{0} = {1}, {2}{3}",
                paramName, obj, predicate,
                string.IsNullOrEmpty(message) ? "" : ", " + message);

            Assert.IsTrue(predicate.Compile().Invoke(obj), msg);
        }

        /// <summary>CollectionAssert.AreEqual</summary>
        public static void Is<T>(this IEnumerable<T> actual, params T[] expected)
        {
            Is(actual, expected.AsEnumerable());
        }

        /// <summary>CollectionAssert.AreEqual</summary>
        public static void Is<T>(this IEnumerable<T> actual, IEnumerable<T> expected, string message = "")
        {
            CollectionAssert.AreEqual(expected.ToArray(), actual.ToArray(), message);
        }
    }

    #endregion

    #region TestCase

    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    public class TestCaseAttribute : Attribute
    {
        public object[] Parameters { get; private set; }

        /// <summary>parameters provide to TestContext.Run.</summary>
        public TestCaseAttribute(params object[] parameters)
        {
            Parameters = parameters;
        }
    }

    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    public class TestCaseSourceAttribute : Attribute
    {
        public string SourceName { get; private set; }

        /// <summary>point out static field/property name. source must be object[][].</summary>
        public TestCaseSourceAttribute(string sourceName)
        {
            SourceName = sourceName;
        }
    }

    public static class TestContextExtensions
    {
        private static IEnumerable<object[]> GetParameters(TestContext context)
        {
            var classType = Type.GetType(context.FullyQualifiedTestClassName);
            var method = classType.GetMethod(context.TestName);

            var testCase = method
                .GetCustomAttributes(typeof(TestCaseAttribute), false)
                .Cast<TestCaseAttribute>()
                .Select(x => x.Parameters);

            var testCaseSource = method
                .GetCustomAttributes(typeof(TestCaseSourceAttribute), false)
                .Cast<TestCaseSourceAttribute>()
                .SelectMany(x =>
                {
                    var p = classType.GetProperty(x.SourceName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
                    var val = (p != null)
                        ? p.GetValue(null, null)
                        : classType.GetField(x.SourceName, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic).GetValue(null);

                    return ((object[])val).Cast<object[]>();
                });

            return testCase.Concat(testCaseSource);
        }
<# for(var i = 1; i <= 16; i++){ #>
        
        /// <summary>Run Parameterized Test marked by TestCase Attribute.</summary>
        public static void Run<#= MakeT(i) #>(this TestContext context, Action<#= MakeT(i) #> assertion)
        {
            foreach (var parameters in GetParameters(context))
            {
                assertion(
<# for(var j = 1; j <= i; j++){ #>
                    (T<#= j #>)parameters[<#= j - 1 #>]<#= (j == i) ? "" : "," #>
<#}#>
                    );
            }
        }
<#}#>
    }

    #endregion
}
<#+
    string MakeT(int count)
    {
        return "<" + string.Join(", ", Enumerable.Range(1, count).Select(i => "T" + i)) + ">";
    }
#>